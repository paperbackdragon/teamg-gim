\section{Client Design}

\subsection{Design of Client Structure}

\subsection{Outline}

This section will outline our initial design of the system. We aimed for a high degree of modularity to separate concerns among team members and improve the ease of maintaining code. The process of identifying the concerns of the client and representing these in a component based design will be discussed in the `Approach' section. The remainder of the section will discuss our design of individual components, and how we identified their roles within the larger system. Particular focus will be made on how we made sure sections of the client were removed as far as possible from other sections, and challenges in ensuring this requirement. 

\subsection{Approach}

In designing the client, we had the high level aim of creating a modular system to allow team members to take responsibility for certain aspects of the system. From an early stage in the design process, we were aware that the client had a large set of responsibilities. We determined these responsibilities to be: to maintain a connection with the server, implement the GIM protocol, provide a user interface to the system and keep a record of up to date information about the user's friends. Our first task was to design a set of interacting sub-components to handle these responsibilities.

It was agreed that the MVC (Model-View-Controller) architectural pattern, widely used for applications involving a graphical user interface, was a useful model to base our discussions around. This model abstracts the UI (view) from the back end of the system. When a user performs an action, the controller updates the model if any data associated with the system is changed, and updates the viewer to reflect these changes in the system state. This seemed appropriate to our needs of keeping and displaying an up-to-date record of the user's friend list and creating an interface, and would allow us to split responsibilities between the back and front end of the GUI.

However, we faced challenges in adapting an additional networking component to implement the GIM protocol into this framework. We had the choice to conceptualise it as either an additional interface, which `viewed' changes to the model, or indirectly (by way of the network) as a part of the controller component. [discussion about possible merits of both goes here] We decided it would be useful to treat the networking code as part of the controller, as it would be modifying the model based on the server's response to its calls, and modifying the GUI to reflect these changes.
	
This high level approach allowed us to draw boundaries between components and assign the more detailed design of individual components to team members. We decided a logical split would be to assign two members to the networking aspects of the system (client and server), and two members to the GUI components of the system (the GUI and its model). However, further collaboration was required as it became more evident what was required for each component, as will be discussed.

[Diagram goes here, reflecting the above discussion (???) ]

\subsection {Model-Viewer-Controller Structural Concerns}

\subsection {Controller}

The controller was one of the more challenging parts of the design process. The controller would be called by both the networking component and the viewer, implying that its operations must be thread safe. We were constrained by our use of the Java Swing\footnote{See \texttt{http://download.oracle.com/javase/6/docs/technotes/guides/swing/} for more information.} environment, which we had learned from previous experience will freeze if the networking code is run on the GUI thread. A further complexity was ensuring that the controller could use the commands of the GIM protocol, without having to know its workings in detail. Naturally, the GUI architects should not need to concern themselves with the specifics of the protocol while designing the GUI.

To deal with the threading complexity, we designed a scheme with an intermediate buffer between the controller component and the networking code. The controller thread waits until there is a command from the network placed into the buffer, and acts accordingly on the model and GUI. Furthermore, when the controller component needs to call the network, it places a command into the buffer to be interpreted by the networking code. We believed this scheme to be appropriate as the controller could either call the network from internal code or events from the GUI (possibly simultaneously).\footnote{See networking design section(***use labels here***) for further discussion on the motivation behind this buffer.}

To deal with the design complexity of abstracting the protocol from the controller's use of its commands, the network architects designed two Java Interfaces, describing the function of methods using java doc. One interface contained method stubs concerning incoming commands from the server, and the other methods that could be called to send commands to the server. This allowed other team members to understand what the controller must do to implement the GIM protocol, without having to understand the inner workings of the protocol. This had the additional advantage of allowing the structure of the protocol to change, without having to change the interface, or consult those team members working on other areas of the GUI. A further provision to remove the responsibility of having to understand the protocol was the inclusion of a parsing method in the controller class the networking architects would write, to parse incoming messages from the server and call the appropriate method. The methods called would could be written by any team member. The networking architects would then be responsible for implementing the methods in the interface for outgoing commands to the server. 

note: not final version
\includegraphics[scale=0.65]{Design/diagrams/buffer.png}

\subsection {Model}

The design of the model involved determining what state information had to be held about the client. This was informed by the previous work of requirements analysis and the conception of features. The model was also informed by the design of the viewer.

Two ``must haves'' of the system were the presence of a contact list and support for user statuses. This implied that there should be data structures for these items. To deal with this requirement, we designed the model to have a data structure to maintain information about users, including their status, nickname and personal messages. 

The view required that the user's own state information (such as status and nickname) were displayed. As these were evident in multiple windows in the view design (such as in chat windows, and on the buddy list), the model was designed to maintain a record of the user's current status. 

\subsection {Viewer}

After some interface design work (which will be discussed in coming sections), it was apparent that the system had to support two different styles of chat windows: a group chat and a chat with a single user. However, there were some observable commonalities between both windows, such as sending messages, displaying incoming messages, and using very similar Java Swing components to handle this functionality. At the same time, there was enough differing behaviour between the two windows to justify having two different classes to handle them, such as the group chat's need to maintain a list of users in the room. With this in mind, we designed our class structure code dealing with the interface to have a super class named ChatWindow, outlining this common functionality, which two sub classes called GroupChatWindow and SingleChatWindow which would extend this super class. 

We anticipated this would be advantageous as it would reduce the repetition of code and keep functionality consistent between the two windows. We felt this consistency would be important, as our code using the Swing components used to display messages would evolve, or need configuring, as we implemented some of our 'should have' features (such as emoticons and font colours.) Therefore, this class structure would be crucial for the displaying of messages in Group Chat and SingleChat windows to remain consistent.

\includegraphics[scale=0.65]{Design/diagrams/chatwin.png}


\subsection{Design of GUI}

As we had decided to incorporate both group and one-to-one chats, this provided a wide scope in terms of interface design. We had the option to base our interface on either IRC or Windows Live Messenger style clients, or to create something entirely of our own. Windows Live was ultimately selected as the basis of the GUI for a number of reasons; primarily we believed that it was better suited to our feature set. An IRC style interface would require a considerable amount of redesigning to accommodate features such as display pictures, contact lists, and offline messaging. While creating our own style of IM interface would be interesting, it would likely lead to an inferior design, and be more time consuming to create. Windows Live style programs typically integrate the vast majority--if not all--of our MoSCoW feature set, and was therefore chosen as our starting point.
 
After we had decided the basic form of the interface, we created a number of use cases for the client interactions.

\subsubsection{Example Use Cases}

The following are examples of key use cases as defined during the design process. These have not been altered for inclusion within this document.

{\bf Add contact}
User clicks the ``add contact'' button in the main window, or the option from the top menu. They are prompted to enter their friend's email. They enter the email and the system searches for that person in the database. If found, the contact is sent a request for friendship. If the contact accepts, then both the user and contact now have each other as contacts, and they show up in the main window. If not accepted, neither is added. If the contact is not found, they are prompted again to enter the email, with the option to cancel.

{\bf Group Chat}
User can choose to group chat from the main window button, main menu, or in a chat window with another contact. A window will show up in which the user can create a chatroom, and then the user will be prompted to choose the contacts they wish to invite. The chatroom appears to the user. Those contacts will see the invitation, and if they accept, will be placed in the chatroom. Contacts will be able to invite other people as well. The chatroom will disappear once every user has left.

{\bf Log Out}
User clicks the ``log out'' option in the menu. The X in the corner will only minimize the program. A dialog box appears, asking if they are sure they want to log out. If yes, they are logged out, and the log in/register pop-up appears. If they want to quit the program completely, they will have to choose ``quit'' from the menu.

At this stage of the process we had begun to make a few implementation decisions, and while some aspects of each use case were omitted in the final product, generally these specifications were adhered to. Much of the redundancy was removed, primarily due to time restrictions. For example the number of ways to start a group chat was reduced to one, from the three ways mentioned in the use case. Group chats can only be started by pressing the button on the main window. However, the other details of the use case are generally true to the implementation.

The use of informal notation for the use cases was, in retrospect, ill-conceived. A more formal notation including pre and post conditions, non-functional requirements, and priorities would have provided a better foundation for implementation. Though, due to the scope of the project and the time restrictions, we felt that these simple use cases were adequate.

\subsubsection{Interface Wireframes}

With the use cases, we started to design a GUI which could accommodate the desired features. Although many UI sketches were made, they were all minor variations on the core design which we derived from the traditional Windows Live Messenger model.


