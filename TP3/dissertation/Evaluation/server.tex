\section{Server Evaluation}
\label{server_eval}

In the earlier stages of our project, the server was in more complete state than our client. This meant we had to develop a method of testing it in isolation, without using the client. We decided an appropriate method would be to send raw protocol commands via Telnet. Telnet allows a connection to be made to a socket, and text to be sent to this socket. As we were in an environment of Computing Science students who were comfortable with such technical tests, we were able to test the server's capability to handling several user accounts simultaneously by using some volunteers, in addition to ourselves to connect. Furthermore, as a group, we had been trained to have testing in mind - and attempts were made to make the server fail by sending it erroneous data to parse from clients.

The primary results these early tests yielded, other than spelling errors, was that the server had trouble when a user authenticated in multiple locations. When a user logs in in multiple locations, the server should send the client that logged in first an error message stating a user logged in elsewhere on that account, and kill this connection, and accept commands from the new client. The server performed these tasks, but did not read commands from the new client. This identified a threading issue which was then corrected. Positively, it gave an early indication that the server was capable of handling many connections at once, and that it was handling the \texttt{::ROOM::} command to the degree users could chat. Naturally, it would be difficult to test some of the more subtle functions of the server using Telnet, but these tests were informative that the server was progressing well. In retrospect, it would have been useful to create a Java program to automate some tests as a more formal test harness, which could have been used through the lifetime of the project. 	

Later tests involved testing features using the client. If a feature the client was trying to use failed, the message sent to the server would be checked for correctness (by using print messages on the string that was to be sent by the socket.) If the correct response was received by the client, which could be determined by reading commands received from the socket before parsing, it could be concluded the server was not at fault. However, in some cases, the server would not behave correctly. One instance involved a correctly formed command to add a friend, to which the server responded with an error saying the command was not formed correctly. At one stage, the friends list was not being displayed by the client. Using this testing process, it was discovered that the server had not spelled 'friend' correctly in multiple places. We were then able to correct spelling errors that had caused parsing issues in the server. 

However, other problems were more conceptual than spelling errors, and involved the semantics of the GIM protocol. The GIM protocol gives permission for users who have certain users on their friendlist to view their contact information such as their personal message, status, and nickname. Secondly, users who are in a group chat with someone who is not on their friends list may also view this information. Testing using the client highlighted that this second case had not been implemented by the server, as required by the protocol. Further, 
