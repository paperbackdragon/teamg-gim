\section{Server Evaluation}
\label{server_eval}

In the earlier stages of our project, the server was in a more complete state than our client. This meant we had to develop a method of testing it in isolation, without using the client. We decided an appropriate method would be to send raw protocol commands via Telnet.\footnote{\texttt{http://www.telnet.org/}} Telnet allows a connection to be made to a socket, and text to be sent within this connection. As we were in an environment of Computing Science students who were comfortable with such technical tests, we were able to test the server's capability to handle several user accounts simultaneously with help from some volunteers. As a group we have been trained to have testing in mind, and attempts were made to make the server fail by sending it erroneous data to parse from clients.

The primary result these early tests yielded, other than spelling errors, was that the server had trouble when a user authenticated in multiple locations. When a user logs in in multiple locations, the server should send the first logged-in client an error message, stating that the account is now logged in at another location. The server then kills the first connection and accept commands from the new client. The server performed these tasks, but did not read commands from the new client. This identified a threading issue which was then corrected. Positively, it gave an early indication that the server was capable of handling many connections at once, and that it was handling the \texttt{:ROOM:} command to the degree that users could chat. Naturally, it would be difficult to test some of the more subtle functions of the server using Telnet, but these tests made it clear that the server was progressing well. It might have been useful if we'd made a Java program to automate tests in a more formal test harness, and used these through the lifetime of the project. 	

Later tests involved testing features using the client GUI. If a feature the client was trying to use failed, the message sent to the server would be checked for correctness. We did this by using print messages on the String that was to be sent by the socket. If the correct response was received by the client, which could be determined by reading commands received from the socket before parsing, it could be concluded the server was not at fault. However, in some cases, the server would not behave correctly. One instance involved a correctly formed command to add a friend, to which the server responded with an error saying the command was not formed correctly. At one stage, the friends list was not being displayed by the client. Using this testing process, it was discovered that the server had not spelled `friend' correctly in multiple places. We were then able to correct spelling errors that had caused parsing issues in the server. 

However, other problems were more conceptual than spelling errors, and involved the semantics of the GIM protocol. The GIM protocol gives permission for users to view each others' information, like personal messages, statuses, and nicknames. Secondly, users who are in a group chat with someone who is not on their friends list may also view this information. Testing using the client highlighted that this second case had not been implemented by the server, as required by the protocol. Also, late testing of the `block' feature via the client revealed an ongoing issue. A user who has been blocked can still see status information about the person who has blocked them, but any messages sent to them will not be delivered. Thus, the server is implementing the `block' feature more like a traditional `ignore' feature and is not following the expected behaviour. Due to time constraints, this issue was not sorted, but will likely be fixed in the future.
