\section{Client Evaluation}
\label{client_eval}

The key aspect of an instant messaging client is ensuring messages get delivered to the correct person and the correct window. It was necessary to establish a way of proving that this worked in every case. This is difficult, as messages take a complicated path through the system. For instance, when a message is received by the network component, a method in the controller is called, which then finds the window corresponding to the sender. In some cases, the delivery of a message has to wait until a window has been created by the Swing thread. The difficulty of proving that a message has been delivered was illustrated by the different behaviours of our program in different environments. During the Christmas break, work was being conducted on our home computers (running Windows and Linux), where we found no evidence of messages being dropped. Upon returning to the university, the first message received was dropped approximately half the time, and an empty chat window appeared. As discussed in section \ref{collab}, we discovered this was a threading issue, where the networking thread `overtook' the GUI thread in an attempt to route the message before the window was created. We were able to discover this by using debugging messages at each stage in the message routing process and in the window creation process. By moving events from the network thread that modified the GUI to the event queue instead, we proved as well as we could that messages would be delivered. As messages were always received from the server in order, the event queue ensured a room would be created before it received a message. 
%TODO: check if this makes more sense now
Additionally, it was important to test that incoming commands were parsed and handed to the corresponding method by the networking component. To test this, first we printed commands as they were parsed as they came from the socket in the GIM protocol syntax. The parsing code then passes the Command object to be another method which works out the method corresponding to the command, by extracting the command, and arguments. The data segment of the command is passed as some structure (usually of a list.) Our second step was to print out the method that was called, and the parameters that it received. This allowed us to match it the arguments received to the data segment to the original print statement with the protocol in its raw form. If the correct method was called corresponding to an incoming command, and the correct arguments given to the function, then the command had been parsed correctly. This method was used for each incoming command. We also checked that all outgoing messages to the server were attempted to be sent. These two straightforward methods were all that was required to conclude that the networking component was working properly in full.

Other features were tested in a less structured manner, and were aided by volunteering Computing Science students who were eager to try and break the client. One such occasion where a user was able to produce undesired behaviour was when they discovered it was possible to inject html into messages, which would then be sent and displayed in the chat window. This allowed users to set their nicknames as html tables, and resize their fonts to huge sizes, for example. This was possible because we implemented the ability to use smileys by using a Swing component that supports html as the message display box. We resolved this issue by replacing HTML brackets with their `special entity' characters.\footnote{\texttt{http://htmlhelp.com/reference/html40/entities/special.html}}

