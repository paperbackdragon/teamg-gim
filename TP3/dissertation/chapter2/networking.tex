\section{Networking Design}

\subsection{Client Networking Structure}

We determined the role of the client networking component to be to maintain a connection with the server, read commands from the command buffer and pass them to the server, and pass commands from the server to the client. These two concerns came with different challenges; where keeping a connection with the server involved considering how to manage writing and reading data to the socket while allowing the client to run efficiently, and sending and receiving commands involved considering how best to parse data coming from the socket, and pass data between components.

\subsubsection {Maintaining a Connection}

The connection to the server had to be designed such that our program could freely write to the socket, and receive commands without having to worry about networking concurrency. For example, the client should not have to worry about doing multiple (possibly simultaneous if there is any multithreaded aspects of its operations) writes to the server, and waiting for these actions to complete. With these considerations in mind, we had to design our component to manage the connection so that the socket would not be written to while a read or write was in progress, while accomodating multiple requests. We had to implement this management in a way that these operations would be hidden from the client. 

Writing to the network was handled by a thread that monitors the buffer for any commands to send to the server. Crucially, commands can accumulate in this buffer, so that the client does not have to wait till a command has completed sending to the socket to continue its operations. As the methods in the buffer are synchronised, it could be ensured that data would remain in a consistent state, and that commands would be sent sequentially. This is of particular importance, as the the networking code would use this buffer to write to the server in order to implement the protocol's 'stay-alive' feature (as discussed in the protocol design section.)  

Reading from the network was handled by designing a class which we named 'NetworkReader.' This class would be run on a thread, and listen to the socket connection for incoming commands. When a command was received, it would then place it onto the intermediate command buffer to be handled by the controller thread (as discussed in section 2.2.4.) The methods within the buffer class would be designed with threading in mind, so that it would remain in a consistent state. A further role of the network reader class would be to inform the client that the connection to the server had been broken, and that action needed to be taken to inform the user and reset any internal information.

\subsubsection {Command Handling }

The parsing of commands was a broad concern that effected both the server and client's activities. This motivated the need to design a 'Command' class which could be used to parse commands. As described in the protocol design section, the GIM protocol follows a structured approach which for each command it is possible to identify the command, argument, and data segments associated with a command. The role of the command class would be to provide facilities that would take a line read from incoming socket data, and create an object from which the individual segements of the command may be extracted. An additional responsibility of this class would be to convert images to and from base64 encoding for transmission over the network (as required by the GIM protocol.)

We thought this was a sensible design decision as it provided a layer of abstraction which allowed the structure of the GIM protocol to change, or additional commands to be added, while only having to change the command class to handle this change. This lead to the design of a 'util' package, as part of our project's structure, while included classes common to both the client and the server networking code. 















