\section{Client Design}

This section will detail the process of designing the GIM client; the application used the communicate with the server. Primarily this will concern the Graphical User Interface (GUI) and the feature set.

\section{Conception of Features}

One of the first tasks for the project was to determine what we beleived to be the important features of an instant messenger, and what was acheivable within the scope of the project. This process involved several team meetings where we simply discussed our experience with a variety of programs and picked areas where we wished to draw from. Due to the popularity of instant messenger programs, they have undergone constant evolution, and continue to do so. Some of our work had already been done.

The constant iteration of instant messenger interfaces provides us with a solid foundation with which to base our client GUI. Our experience of these programs allowed us to highlight features which we felt were acheivable and, more importantly, useful to users. We conceived a feature set split into 4 categories of importance using the MoSCoW method.

\subsubsection{Must Have}

\begin{itemize}
\item{Send Messages}
\item{Graphical User Interface}
\item{User Nicknames}
\item{Contact list}
\item{User Status}
\end{itemize}

\subsubsection{Should Have}

\begin{itemize}
\item{URL Parsing}
\item{Display Pictures}
\item{File Transfers}
\item{Personal Messages}
\item{Smilies}
\end{itemize}

\subsubsection{Could Have}

\begin{itemize}
\item{User Profile}
\item{Custom Commands}
\item{Themes}
\item{Plug-in Support}
\item{VoIP}
\end{itemize}

\subsubsection{Would Like To Have}

\begin{itemize}
\item{Contact List Grouping}
\item{Offline Messaging}
\item{Chat Logging}
\item{Custom Fonts and Colours}
\end{itemize}

This list was decided upon by taking into account what we belived to be each features' necessity, usefulness, and diffiulty of implementation. The requirements in the ``Must Have'' category were taken from the initial problem specification, and the other categories were decided using the criteria described previously.

The ``Must Have" features generally contain the basic elements of an instant messenger, such as sending messages and a graphical user interface. Of note is the inclusion of user statues; this was included here as at a basic level, status would simply indicate whether a user was online or not. The final application also supports ``Away" and ``Busy", but these are less important than ``Online" or ``Offline" as these have implications beyond what the end user will see.

Should Have features are those which we felt were within the scope of the project and would significantly enhance the users' experience. URL parsing is the ability for user to select hyperlinks in the chat window. This was given high priority due to our experience of using other IM clients, which often involves sending contacts links to various websites. Display pictures are images that a user uses to represent themselves with to their contacts. While display pictures do not directly impact the functionality of the program, we felt that they would make the chatting experience more personal and users may expect to see what has been a standard feature of similar programs for some time. We considered the ability to send files between users to be a useful feature but were are that it would potentially be one of the most difficult items on the list to implement. Personal messages are one of the easier features on the list. A personal message is a small message a user sets on the interface that all other users can see, typically underneath the username and given less prominence. As this was considered to be simple to implement, it was assigned a relativly high priority. Smilies (also known as emoticons) are small icons used to represent emotions in chat. While they add visual appeal, smilies would not add significant functionality as text-based representations can be used.

Many of the could have features involve customisation of the interface. User profiles are pages in the interface which would contain details on that user which can be viewed by contacts. 

\subsection{GUI Structure}
2.2.2 Design of Client Structure

[intro, with some context goes here (?)]

2.2.2.1 Approach

In designing the client, we had the high level aim of creating a modular system to allow team members to take responsibility for certain aspects of the system. From an early stage in the design process, we were aware that the client had a large set of responsibilities. We determined these responsibilities to be;  to maintain a connection with the server, implement the GIM protocol, provide a user interface to the system and keep a record of up to date information about the user’s friends. Our first task was to design a set of interacting sub-components to handle these responsibilities.

It was agreed that the MVC (Model-Viewer-Controller) architectural pattern, widely used for applications involving a graphical user interface, was a useful model to base our discussions around. This model abstracts the UI (view) from the back end of the system. When a user performs an action, the controller updates a collection of data associated with the system, and updates the interface to reflect any changes the user needs to know about. This seemed appropriate to our needs of keeping and displaying an up to record about the user’s friend list and creating an interface, and would allow us to split responsibilities between the back and front end of the GUI. 

However, we faced challenges in adapting an additional networking component, to implement the GIM protocol, into this framework. We had the choice to conceptually view it as either an additional interface, which ‘viewed’ changes to the model, or indirectly (by way of the network) the controller component. [discussion about possible merits of both goes here] We decided it would be useful to treat the networking code as part of the controller, as it would be modifying the model based on the server’s response to its calls, and modifying the GUI to reflect these changes.
	
This high level approach allowed us to draw high level boundaries between components, and assign the more detailed design of individual components to team members. We decided a logical split would be to assign two members to the networking aspects of the system (client and server), and two members to the GUI components of the system (the GUI and its model.) However, further collaboration was required as it became more evident what was required from each component, from other components, as will be discussed. 

[Diagram goes here, reflecting the above discussion (???) ]

2.2.2.2 Model-Viewer-Controller Structural Concerns

Model




Controller

The controller was one of the more challenging parts of the design process. The controller would be called by both the networking component, and the viewer, implying that its operations must be thread safe. We were constrained by our use of the swing environment, which we had learned from previous experience, will freeze if the networking code is ran on the thread running the GUI. A further complexity was handling the boundary between the requirements of the network code, and the protocol that was being handled by the networking code. Naturally, the GUI architects should not need to concern themselves with the specifics of the protocol, while designing the GUI. 

To deal with the threading complexity, we designed a scheme whereby there would be an intermediate buffer between the controller component, and the networking code. The controller thread would wait until there was a command from the network placed onto the buffer, and act accordingly. Furthermore, when the controller component needed to call the network, it would place a command onto the buffer, to be interpreted by the  networking code. We believed this scheme to be appropriate as controller could either call the network from internal code, or events from the GUI (possibly simultaneously).

[Fancy picture showing this could go here] 

To deal with the design complexity of the boundary, we decided that initially, an interface would be written by the networking architects, including javadoc, to describe the requirements of the GIM protocol of the client, from the controller. In the implementation, the controller would then implement this interface. This allowed the requirements from the client to be understood, without having to understand the inner workings of the protocol. Furthermore, the structure of the protocol could change, without any change to the interface or consultation with the GUI architects. The networking architect would write code to parse incoming commands to calls these methods described by the interface, and write outgoing commands from the GUI.

[NOTE: WRITE IN IMPLENTATION SECTION, THIS DIDN’T HAPPEN. (okay, lower case time)... Instead, we put things onto swing’s event queue, and only used the buffer for outgoing traffic. We decided the parsing code was best placed in the network reading thread, to keep the code tidy. Furthermore, this hid the protocol code from the GUI more...]
