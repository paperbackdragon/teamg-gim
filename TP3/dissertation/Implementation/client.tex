\section{Client}

\subsection{Overview}

This section will analyse how appropriate our client design  was for the purpose of achieving the aims outlined in the client section.\footnote{See section x.y for a detailed discussion}  Some of our design choices worked well to achieve our aims, such as the interfaces used by the controller to separate concerns. Another decision that worked well was our use of the object oriented features of java to implement chat windows, which ended up reducing the problem of internal routing of messages to the correct windows. These aspects will be discussed in the 'Design Changes' section.

While implementing the client, it became clear that some of our larger design choices were naive, and further design work had to be conducted. One case involved the interaction between the controller and networking subsystem. These changes will be discussed in the 'Design' Changes section. In some cases, smaller design choices required larger changes. Of particular significance, our understanding of the practical working of the GIM protocol to create personal chats proved to be ill informed. This required design work reaching over the protocol, and the model component of the system. This process tested our ability to collaborate as a team to implement an interacting system. The degree of our success of our changes will be discussed in the 'Collaboration' section. Furthermore, as we became more familiar with the swing environment, our code went through evolutionary steps to implement certain features in a more sensible manner, such as how displaying updates to user information was handled. The 'Evolution of Code' section will discuss problems we identified with code, which was functional,  but deemed to be hard to maintain on reviewing our code, such as in the above case case, and the merits of our changes we made. 

\subsection{Design Changes}

\subsection{Collaboration}

The first draft of the GIM protocol considered all conversations as 'rooms', and did not distinguish group chats and personal chats.\footnote{internal reference to protocol section} In designing the protocol, we wished to keep it abstract and not fall into the trap of implicitely implementing features that the internal workings of the client and server could handle. Our goal was not to develop a protocol suitable for only one type of implementation. Originally, it was believed that the client could distinguish personal chats and group chats by storing internal records of the type of outgoing invites to chat. In the case of being invited to chat, we believed using the protocol's "USER" argument in the "ROOM" command would be sufficient to count the amount of users in the "room" and determine the type of chat. However, as we began implementing room creation, it became clear that the initial group user list could be 1, and thus the wrong chat window could be created. As a result, the protocol engineer had to be consulted to make changes to the protocol, and the client ammended to reflect these changes. 

This change was a test of the boundary of responsibilites within our client structure, as it effected communication with the server, and the back end of the server. The protocol engineer's solution to the issue was to add a 'type' argument to the room command. In the case creating a room, the type now had to be specified. To allow a user to work out what room type a chat had, the 'type' argument was used, with a room identifier. This kept the protocol abstract, as some clients may not be interested in this. In order to deal with these changes, our client had to be designed to sequence responses from the server with certain requests. As the protocol did not include sequence numbers, we had to re-design the model to perform this task.


\subsection{Evolution of Code}
