\section{Client}

\subsection{Overview}

This section will analyse how appropriate our client design was to achieve the aims outlined in the client section\footnote{See section x.y for a detailed discussion}. Some of our design choices worked well, such as the interfaces used by the controller to separate concerns. Another decision that worked well was our use of the object oriented features of Java to implement chat windows, which reduced the challenge of routing internal messages to the correct windows. These aspects will be discussed in the `Design Changes' section.

While implementing the client, it became clear that some of our larger design choices were naive, and further design work had to be conducted. One case involved the interaction between the controller and networking subsystem. These changes will be discussed in the `Design Changes' section. In some cases, smaller design choices required larger changes. Of particular significance, our understanding of the practical working of the GIM protocol to create personal chats proved to be weak. This required design work reaching over the protocol and the model component of the system. This process tested our ability to collaborate as a team to implement an interacting system. The degree of success of our changes will be discussed in the 'Collaboration' section. Furthermore, as we became more familiar with the Java Swing environment, our code went through evolutionary steps to implement certain features in a more sensible manner, such as how displaying updates to user information was handled. The 'Evolution of Code' section will discuss problems we identified with code that was functional but deemed to be hard to maintain, and the merits of the changes we made, such as in the above case. 

\subsection{Design Changes}



\subsection{Collaboration}

The first draft of the GIM protocol treated all conversations as `rooms' and did not distinguish group chats and personal chats\footnote{internal reference to protocol section}. In designing the protocol, we wished to keep it abstract and not fall into the trap of implicitly implementing features that the client and server could handle. Our goal was not to develop a protocol suitable for only one type of implementation. Originally, it was believed that the client could distinguish personal chats and group chats by storing internal records of the type of outgoing invites to chat. In the case of being invited to chat, we believed using the protocol's ``USER'' argument in the ``::ROOM::'' command would be sufficient to count the amount of users in the room and determine the type of chat. However, as we began implementing room creation, it became clear that the initial group user list could be of size 1, and thus the wrong chat window could be created. As a result, the protocol had to be changed, and the client amended to reflect these changes. 

This change was a test of the boundary of responsibilities within our system, as it effected communication with the server and the back end of the client. The protocol engineer's solution to the issue was to add a `type' argument to the room command. In the case creating a room, the type now had to be specified. To allow a user to work out what room type a chat had, the `type' argument would be used, with a room identifier. This kept the protocol more abstract. In order to deal with these changes, our client had to be designed to sequence responses from the server for certain requests. As the protocol did not include sequence numbers, we had to re-design the model to perform this task. It was apparent that the amount of ``talk'' between the client and server required to start a chat was now increased. This required an understanding of what needed to be stored at each stage. This high level plan was determined:

Creation:
\begin{enumerate}
\item Client adds the type of room to be created to the new room queue in the model.
\item Client notes a list of user(s) invited to chat in the invitations queue in the model.
\item Client sends request to server to create a room of this type.
\item Server responds with `created' and the room id.
\item Client matches the type of chat with the `new room' queue, and the user list from the `invitations' queue.
\item Client spawns the appropriate chat window, or updates the internal state information of an existing window with the new roomid in the window list. Information includes who is in the room and the id to send messages to.
\item Client is informed that the participant has joined the room, through the 'joined' argument in the "::ROOM::" command.
\end {enumerate}

Invitation:
\begin{enumerate}
\item Client receives invite to chat from server with certain room id from user. Store username in an ``invited'' queue in model.  
\item Client asks server the type of the room that it has been invited to.
\item Server responds with `Personal' or `Group.'
\item Client matches request with response from the ``invited'' queue.
\item Client spawns the appropriate chat window, or updates the internal state information of an existing window with the new roomid in the window list. Information includes who is in the room and the id to send messages to.
\item Client is informed that the participant has joined the room, through the 'joined' argument in the "::ROOM::" command.
\item If it is a group chat, client asks server for the user list in the room.
\end{enumerate}

In retrospect, the trade off between keeping an abstract protocol (which could be used for different styles of implementation) and designing towards our own client and server may have been too high. Aside from the communication between the client and the server, there are complexities within the client code to ensure these events are performed in sequence which left much opportunity for error in the control of threading. For example, a user should not be allowed to send a message before the conversation participant has also joined the room, in the case of a personal chat between steps 6 and 7. This meant that safeguards had to be considered during this sequence of events to ensure messages were not dropped, while ensuring the user did not have to `wait' for the other user to enter the room before entering a message. This motivated the need for a boolean value (internal to chat windows) indicating whether the chat participant was in the room. While this value is false, messages to be sent are buffered until it turns true. A further issue of synchronization was internal to the code. Since the GUI was running on a separate thread from the incoming networking thread, it was conceivable that an incoming message could occur before the internal room id was updated in step 6. In fact, this issue was subtle enough that it was not recognised until late in development. In retrospect, part of our problem was from not identifying where the Swing event queue needed to be used (as outlined in the previous section), as well as the complex set of events that needed to occur to establish a chat. Throughout this project, we became more aware of the careful approach required when using threads.

\subsection{Evolution of Code}

As described in the design section, a requirement from the client model was to store information about users.\footnote{reference goes here} During the early stages of the implementation, it was believed it would be sufficient to get display the the user's nickname in a chat window, by polling the 'User' list stored in the model any time a message was received. However, as the implementation progressed it became clear that many areas on the interface dynamically updated friend information - including the contact list, group chat window, and single chat window. As the implementation of these interface features was gradual, the original approach was to update each area of the interface in isolation whenever the server alerted the client of a change. We encountered problems with this approach when an error was encountered which caused the client to go into an infinate loop of being informed there was an update to a user's information, then sending a request to the server to receive this update. The behaviour of updating informational was coupled across many classes, and it was therefor difficult to track down the source of the problem. As the team became familiar with swing, it was realised that the behaviour could be uncoupled to a degree by implementing swing's 'listener' interface on the User collection in the model, where content was dynamic. This meant that any time user information changed, the listener event would update the interface in any place neccessary. This change successfully made our code easier to maintain, and scalable, as it is possible in future development information about friends may be displayed on other windows. 

A further significant evolution in our code, also centered around out use of swing, was a need to overcome a significant problem while rendering the contact list. 